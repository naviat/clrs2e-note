\documentclass[a4paper, fleqn]{article}
\usepackage{amsmath}
\usepackage{clrscode}
\usepackage{hyperref}
\setlength\mathindent{0em}
\parskip = 7bp

\title{Solutions for Chapter 21}
\author{Zhixiang Zhu
\\\href{mailto:zzxiang21cn@hotmail.com}{zzxiang21cn@hotmail.com}}
\begin{document}

\maketitle

\section*{Solution to Exercise 21.1-1}

\begin{align*}
&(d, i): \{a\}, \{b\}, \{c\}, \{d, i\}, \{e\}, \{f\}, \{g\}, \{h\}, \{j\}, \{k\} \\
&(f, k): \{a\}, \{b\}, \{c\}, \{d, i\}, \{e\}, \{f, k\}, \{g\}, \{h\}, \{j\} \\
&(g, i): \{a\}, \{b\}, \{c\}, \{d, g, i\}, \{e\}, \{f, k\}, \{h\}, \{j\} \\
&(b, g): \{a\}, \{b, d, g, i\}, \{c\}, \{e\}, \{f, k\}, \{h\}, \{j\} \\
&(a, h): \{a, h\}, \{b, d, g, i\}, \{c\}, \{e\}, \{f, k\}, \{j\} \\
&(i, j): \{a, h\}, \{b, d, g, i, j\}, \{c\}, \{e\}, \{f, k\} \\
&(d, k): \{a, h\}, \{b, d, f, g, i, j, k\}, \{c\}, \{e\} \\
&(b, j): \{a, h\}, \{b, d, f, g, i, j, k\}, \{c\}, \{e\} \\
&(d, f): \{a, h\}, \{b, d, f, g, i, j, k\}, \{c\}, \{e\} \\
&(g, j): \{a, h\}, \{b, d, f, g, i, j, k\}, \{c\}, \{e\} \\
&(a, e): \{a, e, h\}, \{b, d, f, g, i, j, k\}, \{c\} \\
\end{align*}






\section*{Solution to Exercise 21.1-2}

We can prove it by contradiction. If two vertices $u$ and $v$ in the
same connected component are not in the same set, then at least one
edge on the path connecting $u$ and $v$ hasn't been processed, so that
$u$ and $v$ are not united. That contradicts the assumption of all
edges having been processed.






\section*{Solution to Exercise 21.1-3}

\proc{Find-Set} is called $2|E|$ times. \proc{Union} is called $|V| -
k$ times.






\section*{Solution to Exercise 21.2-2}

All the elements are united into one set, so the two \proc{Find-Set}
operations in the end both return $x_1$.





\section*{About the Solution to Exercise 21.2-3}

The instructor's manual has given the solution, which says ``if you go
through the theorem with $l$ \proc{Union}s, you get the time bound
$O(m - l + l \lg l) = O(m + l \lg l)$ for the sequence of
operations.'' This is because the largest set has at most $l$ members,
in which each object's representative pointer has been updated at most
$\lceil \lg l \rceil$ times.






\section*{Solution to Exercise 21.3-2}

\begin{codebox}
\Procname{\proc{Find-Set}$(x)$}
\li $y \gets x$
\li create a stack $S$
\li \While $y \neq p[y]$
\li   \Do
        push $y$ into $S$
\li     $y \gets p[y]$
      \End
\li \While $S$ is not empty
\li   \Do
        pop the top of $S$ to $z$
\li     $p[z] \gets y$
      \End
\li \Return $y$
\end{codebox}






\section*{Solution to Exercise 21.4-2}

If $n = 1$, there's only one node whose rank is 0 and will not
increase, of course the rank is no larger than $\lfloor\lg k\rfloor$.

If $n > 1$, each node's rank starts at 0, and it increases only upon
\proc{Link} operations when the rank of the node linked to it is the
same as its before linking. A tree whose root is of rank 0 contains
only one node.  If a node's rank increases from 0 to 1, the newly
formed tree will contain 2 nodes. If a node's rank increases from 1 to
2, the newly formed tree will contain at least 4 nodes. Continuing on,
we observe that, if a node's rank increases from $k - 1$ to $k$, the
newly formed tree will contain at least $2^k$ nodes, where $k \geq 1$.
Since $2^k \leq n$, we have $k \leq \lfloor\lg n\rfloor$, so every
node's rank can increase to at most $\lfloor\lg n\rfloor$.

\end{document}
